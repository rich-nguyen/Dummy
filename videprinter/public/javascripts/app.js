(function(){/*
 MIT License (c) copyright 2010-2013 B Cavalier & J Hann */
(function(l){function p(){}function v(a,b){return 0==T.call(a).indexOf("[object "+b)}function x(a){return a&&"/"==a.charAt(a.length-1)?a.substr(0,a.length-1):a}function D(a,b){var d,c,f,g;d=1;c=a;"."==c.charAt(0)&&(f=!0,c=c.replace(U,function(a,b,c,f){c&&d++;return f||""}));if(f){f=b.split("/");g=f.length-d;if(0>g)return a;f.splice(g,d);return f.concat(c||[]).join("/")}return c}function C(a){var b=a.indexOf("!");return{g:a.substr(b+1),d:0<=b&&a.substr(0,b)}}function A(){}function y(a,b){A.prototype=
a||N;var d=new A;A.prototype=N;for(var c in b)d[c]=b[c];return d}function E(){function a(a,b,d){c.push([a,b,d])}function b(a,b){for(var d,f=0;d=c[f++];)(d=d[a])&&d(b)}var d,c,f;d=this;c=[];f=function(d,n){a=d?function(a){a&&a(n)}:function(a,b){b&&b(n)};f=p;b(d?0:1,n);b=p;c=s};this.m=function(b,c,f){a(b,c,f);return d};this.h=function(a){d.C=a;f(!0,a)};this.f=function(a){d.qa=a;f(!1,a)};this.w=function(a){b(2,a)}}function z(a){return a instanceof E||a instanceof h}function t(a,b,d,c){z(a)?a.m(b,d,c):
b(a)}function B(a,b,d){var c;return function(){0<=--a&&b&&(c=b.apply(s,arguments));0==a&&d&&d(c);return c}}function e(){var a,b;r="";a=[].slice.call(arguments);v(a[0],"Object")&&(b=a.shift(),b=w(b));return new h(a[0],a[1],a[2],b)}function w(a,b,d){var c;r="";if(a&&(k.R(a),q=k.b(a),"preloads"in a&&(c=new h(a.preloads,s,d,I,!0),k.l(function(){I=c})),a=a.main))return new h(a,b,d)}function h(a,b,d,c,f){var g;g=k.k(q,s,[].concat(a),f);this.then=this.m=a=function(a,b){t(g,function(b){a&&a.apply(s,b)},function(a){if(b)b(a);
else throw a;});return this};this.next=function(a,b,c){return new h(a,b,c,g)};this.config=w;(b||d)&&a(b,d);k.l(function(){t(f||I,function(){t(c,function(){k.r(g)},d)})})}function K(a){var b,d;b=a.id;b==s&&(J!==s?J={I:"Multiple anonymous defines encountered"}:(b=k.da())||(J=a));if(b!=s){d=u[b];b in u||(d=k.j(b,q),d=k.F(d.b,b),u[b]=d);if(!z(d))throw Error("duplicate define: "+b);d.ha=!1;k.G(d,a)}}function F(){var a=k.aa(arguments);K(a)}var r,q,G,H,m=l.document,O=m&&(m.head||m.getElementsByTagName("head")[0]),
V=O&&O.getElementsByTagName("base")[0]||null,Q={},R={},L={},W="addEventListener"in l?{}:{loaded:1,complete:1},N={},T=N.toString,s,u={},M={},I=!1,J,S=/^\/|^[^:]+:\/\//,U=/(\.)(\.?)(?:$|\/([^\.\/]+.*)?)/g,X=/\/\*[\s\S]*?\*\/|\/\/.*?[\n\r]/g,Y=/require\s*\(\s*(["'])(.*?[^\\])\1\s*\)|[^\\]?(["'])/g,Z=/\s*,\s*/,P,k;k={n:function(a,b,d){var c;a=D(a,b);if("."==a.charAt(0))return a;c=C(a);a=(b=c.d)||c.g;a in d.c&&(a=d.c[a].M||a);b&&(0>b.indexOf("/")&&!(b in d.c)&&(a=x(d.P)+"/"+b),a=a+"!"+c.g);return a},k:function(a,
b,d,c){function f(b,c){var d,g;d=k.n(b,n.id,a);if(!c)return d;g=C(d);if(!g.d)return d;d=u[g.d];g.g="normalize"in d?d.normalize(g.g,f,n.b)||"":f(g.g);return g.d+"!"+g.g}function g(b,d,g){var e;e=d&&function(a){d.apply(s,a)};if(v(b,"String")){if(e)throw Error("require(id, callback) not allowed");g=f(b,!0);b=u[g];if(!(g in u))throw Error("Module not resolved: "+g);return(g=z(b)&&b.a)||b}t(k.r(k.k(a,n.id,b,c)),e,g)}var n;n=new E;n.id=b||"";n.ea=c;n.H=d;n.b=a;n.A=g;g.toUrl=function(b){return k.j(f(b,!0),
a).url};n.n=f;return n},F:function(a,b,d){var c,f,g;c=k.k(a,b,s,d);f=c.h;g=B(1,function(a){c.q=a;try{return k.V(c)}catch(b){c.f(b)}});c.h=function(a){t(d||I,function(){f(u[c.id]=M[c.url]=g(a))})};c.J=function(a){t(d||I,function(){c.a&&(g(a),c.w(R))})};return c},U:function(a,b,d,c){return k.k(a,d,s,c)},ca:function(a){return a.A},K:function(a){return a.a||(a.a={})},ba:function(a){var b=a.t;b||(b=a.t={id:a.id,uri:k.L(a),exports:k.K(a),config:function(){return a.b}},b.a=b.exports);return b},L:function(a){return a.url||
(a.url=k.D(a.A.toUrl(a.id),a.b))},R:function(a){var b,d,c,f,g;b="curl";d="define";c=f=l;if(a&&(g=a.overwriteApi||a.oa,b=a.apiName||a.ja||b,c=a.apiContext||a.ia||c,d=a.defineName||a.la||d,f=a.defineContext||a.ka||f,G&&v(G,"Function")&&(l.curl=G),G=null,H&&v(H,"Function")&&(l.define=H),H=null,!g)){if(c[b]&&c[b]!=e)throw Error(b+" already exists");if(f[d]&&f[d]!=F)throw Error(d+" already exists");}c[b]=e;f[d]=F},b:function(a){function b(a,b){var d,c,n,e,q;for(q in a){n=a[q];v(n,"String")&&(n={path:a[q]});
n.name=n.name||q;e=f;c=C(x(n.name));d=c.g;if(c=c.d)e=g[c],e||(e=g[c]=y(f),e.c=y(f.c),e.e=[]),delete a[q];c=n;var r=b,h=void 0;c.path=x(c.path||c.location||"");r&&(h=c.main||"./main","."==h.charAt(0)||(h="./"+h),c.M=D(h,c.name+"/"));c.b=c.config;c.b&&(c.b=y(f,c.b));c.S=d.split("/").length;d?(e.c[d]=c,e.e.push(d)):e.o=k.Q(n.path,f)}}function d(a){var b=a.c;a.O=RegExp("^("+a.e.sort(function(a,c){return b[c].S-b[a].S}).join("|").replace(/\/|\./g,"\\$&")+")(?=\\/|$)");delete a.e}var c,f,g,n;"baseUrl"in
a&&(a.o=a.baseUrl);"main"in a&&(a.M=a.main);"preloads"in a&&(a.pa=a.preloads);"pluginPath"in a&&(a.P=a.pluginPath);if("dontAddFileExt"in a||a.i)a.i=RegExp(a.dontAddFileExt||a.i);c=q;f=y(c,a);f.c=y(c.c);g=a.plugins||{};f.plugins=y(c.plugins);f.v=y(c.v,a.v);f.u=y(c.u,a.u);f.e=[];b(a.packages,!0);b(a.paths,!1);for(n in g)a=k.n(n+"!","",f),f.plugins[a.substr(0,a.length-1)]=g[n];g=f.plugins;for(n in g)if(g[n]=y(f,g[n]),a=g[n].e)g[n].e=a.concat(f.e),d(g[n]);for(n in c.c)f.c.hasOwnProperty(n)||f.e.push(n);
d(f);return f},j:function(a,b){var d,c,f,g;d=b.c;f=S.test(a)?a:a.replace(b.O,function(a){c=d[a]||{};g=c.b;return c.path||""});return{b:g||q,url:k.Q(f,b)}},Q:function(a,b){var d=b.o;return d&&!S.test(a)?x(d)+"/"+a:a},D:function(a,b){return a+((b||q).i.test(a)?"":".js")},s:function(a,b,d){var c=m.createElement("script");c.onload=c.onreadystatechange=function(d){d=d||l.event;if("load"==d.type||W[c.readyState])delete L[a.id],c.onload=c.onreadystatechange=c.onerror="",b()};c.onerror=function(){d(Error("Syntax or http error: "+
a.url))};c.type=a.N||"text/javascript";c.charset="utf-8";c.async=!a.fa;c.src=a.url;L[a.id]=c;O.insertBefore(c,V);return c},W:function(a){var b=[],d;("string"==typeof a?a:a.toSource?a.toSource():a.toString()).replace(X,"").replace(Y,function(a,f,g,e){e?d=d==e?s:d:d||b.push(g);return""});return b},aa:function(a){var b,d,c,f,g,e;g=a.length;c=a[g-1];f=v(c,"Function")?c.length:-1;2==g?v(a[0],"Array")?d=a[0]:b=a[0]:3==g&&(b=a[0],d=a[1]);!d&&0<f&&(e=!0,d=["require","exports","module"].slice(0,f).concat(k.W(c)));
return{id:b,q:d||[],B:0<=f?c:function(){return c},p:e}},V:function(a){var b;b=a.B.apply(a.p?a.a:s,a.q);b===s&&a.a&&(b=a.t?a.a=a.t.a:a.a);return b},G:function(a,b){a.B=b.B;a.p=b.p;a.H=b.q;k.r(a)},r:function(a){function b(a,b,c){e[b]=a;c&&r(a,b)}function d(b,c){var d,f,g,e;d=B(1,function(a){f(a);m(a,c)});f=B(1,function(a){r(a,c)});g=k.Y(b,a);(e=z(g)&&g.a)&&f(e);t(g,d,a.f,a.a&&function(a){g.a&&(a==Q?f(g.a):a==R&&d(g.a))})}function c(){a.h(e)}var f,g,e,q,h,r,m;e=[];g=a.H;q=g.length;0==g.length&&c();r=
B(q,b,function(){a.J&&a.J(e)});m=B(q,b,c);for(f=0;f<q;f++)h=g[f],h in P?(m(P[h](a),f,!0),a.a&&a.w(Q)):h?d(h,f):m(s,f,!0);return a},Z:function(a){k.L(a);k.s(a,function(){var b=J;J=s;!1!==a.ha&&(!b||b.I?a.f(Error(b&&b.I||"define() missing or duplicated: "+a.url)):k.G(a,b))},a.f);return a},Y:function(a,b){var d,c,f,g,e,h,r,m,w,l,p,s;d=b.n;c=b.ea;f=b.b||q;e=d(a);e in u?h=e:(g=C(e),m=g.g,h=g.d||m,w=k.j(h,f));if(!(e in u))if(s=k.j(m,f).b,g.d)r=h;else if(r=s.moduleLoader||s.na||s.loader||s.ma)m=h,h=r,w=
k.j(r,f);h in u?l=u[h]:w.url in M?l=u[h]=M[w.url]:(l=k.F(s,h,c),l.url=k.D(w.url,w.b),u[h]=M[w.url]=l,k.Z(l));h==r&&(g.d&&f.plugins[g.d]&&(s=f.plugins[g.d]),p=new E,t(l,function(a){var b,f,g;g=a.dynamic;m="normalize"in a?a.normalize(m,d,l.b)||"":d(m);f=r+"!"+m;b=u[f];if(!(f in u)){b=k.U(s,f,m,c);g||(u[f]=b);var e=function(a){g||(u[f]=a);b.h(a)};e.resolve=e;e.reject=e.error=b.f;a.load(m,b.A,e,s)}p!=b&&t(b,p.h,p.f,p.w)},p.f));return p||l},da:function(){var a;if(!v(l.opera,"Opera"))for(var b in L)if("interactive"==
L[b].readyState){a=b;break}return a},$:function(a){var b=0,d,c;for(d=m&&(m.scripts||m.getElementsByTagName("script"));d&&(c=d[b++]);)if(a(c))return c},X:function(){var a,b="";(a=k.$(function(a){(a=a.getAttribute("data-curl-run"))&&(b=a);return a}))&&a.setAttribute("data-curl-run","");return b},T:function(){function a(){k.s({url:c.shift()},b,b)}function b(){r&&(c.length?(k.l(d),a()):d("run.js script did not run."))}function d(a){throw Error(a||"Primary run.js failed. Trying fallback.");}var c=r.split(Z);
c.length&&a()},l:function(a){setTimeout(a,0)}};P={require:k.ca,exports:k.K,module:k.ba};e.version="0.8.4";e.config=w;F.amd={plugins:!0,jQuery:!0,curl:"0.8.4"};q={o:"",P:"curl/plugin",i:/\?|\.js\b/,v:{},u:{},plugins:{},c:{},O:/$^/};G=l.curl;H=l.define;G&&v(G,"Object")?(l.curl=s,w(G)):k.R();(r=k.X())&&k.l(k.T);u.curl=e;u["curl/_privileged"]={core:k,cache:u,config:function(){return q},_define:K,_curl:e,Promise:E}})(this.window||"undefined"!=typeof global&&global||this);
(function(l,p){function v(){if(!p.body)return!1;F||(F=p.createTextNode(""));try{return p.body.removeChild(p.body.appendChild(F)),F=K,!0}catch(e){return!1}}function x(){var r;r=A[p[C]]&&v();if(!z&&r){z=!0;for(clearTimeout(h);e=w.pop();)e();E&&(p[C]="complete");for(var q;q=y.shift();)q()}return r}function D(){x();z||(h=setTimeout(D,t))}var C="readyState",A={loaded:1,interactive:1,complete:1},y=[],E=p&&"string"!=typeof p[C],z=!1,t=10,B,e,w=[],h,K,F;B="addEventListener"in l?function(e,h){e.addEventListener(h,
x,!1);return function(){e.removeEventListener(h,x,!1)}}:function(e,h){e.attachEvent("on"+h,x);return function(){e.detachEvent(h,x)}};p&&!x()&&(w=[B(l,"load"),B(p,"readystatechange"),B(l,"DOMContentLoaded")],h=setTimeout(D,t));define("curl/domReady",function(){function e(h){z?h():y.push(h)}e.then=e;e.amd=!0;return e})})(this,this.document);
(function(l,p,v){define("curl/plugin/js",["curl/_privileged"],function(l){function D(e,w,h){function p(){r||(t<new Date?h():setTimeout(p,10))}var t,r,q;t=(new Date).valueOf()+(e.ga||3E5);h&&e.a&&setTimeout(p,10);q=l.core.s(e,function(){r=!0;e.a&&(e.C=v(e.a));!e.a||e.C?w(q):h()},function(e){r=!0;h(e)})}function C(e,l){D(e,function(){var h=y.shift();t=0<y.length;h&&C.apply(null,h);l.h(e.C||!0)},function(e){l.f(e)})}var A={},y=[],E=p&&!0==p.createElement("script").async,z,t,B=/\?|\.js\b/;z=l.Promise;
return{dynamic:!0,normalize:function(e,l){var h=e.indexOf("!");return 0<=h?l(e.substr(0,h))+e.substr(h):l(e)},load:function(e,l,h,p){function v(e){(h.error||function(e){throw e;})(e)}var r,q,x,H,m;r=0<e.indexOf("!order");q=e.indexOf("!exports=");x=0<q?e.substr(q+9):p.a;H="prefetch"in p?p.prefetch:!0;e=r||0<q?e.substr(0,e.indexOf("!")):e;q=(q=p.dontAddFileExt||p.i)?RegExp(q):B;m=l.toUrl(e);q.test(m)||(m=m.lastIndexOf(".")<=m.lastIndexOf("/")?m+".js":m);m in A?A[m]instanceof z?A[m].m(h,v):h(A[m]):(e=
{name:e,url:m,fa:r,a:x,ga:p.timeout},A[m]=l=new z,l.m(function(e){A[m]=e;h(e)},v),r&&!E&&t?(y.push([e,l]),H&&(e.N="text/cache",D(e,function(e){e&&e.parentNode.removeChild(e)},function(){}),e.N="")):(t=t||r,C(e,l)))},cramPlugin:"../cram/js"}})})(this,this.document,function(l){try{return eval(l)}catch(p){}});define("curl/plugin/domReady",["../domReady"],function(l){return{load:function(p,v,x){l(x)}}});
}).call(this);

eval("/*!\n  * @preserve Qwery - A Blazing Fast query selector engine\n  * https://github.com/ded/qwery\n  * copyright Dustin Diaz 2012\n  * MIT License\n  */\n\n(function (name, context, definition) {\n  if (typeof module != \'undefined\' && module.exports) module.exports = definition()\n  else if (typeof define == \'function\' && define.amd) define(\'qwery\',definition)\n  else context[name] = definition()\n})(\'qwery\', this, function () {\n\n  var classOnly = /^\\.([\\w\\-]+)$/\n    , doc = document\n    , win = window\n    , html = doc.documentElement\n    , isAncestor = \'compareDocumentPosition\' in html ?\n        function (element, container) {\n          return (container.compareDocumentPosition(element) & 16) == 16\n        } :\n        function (element, container) {\n          container = container == doc || container == window ? html : container\n          return container !== element && container.contains(element)\n        }\n\n  function toArray(ar) {\n    return [].slice.call(ar, 0)\n  }\n\n  function isNode(el) {\n    var t\n    return el && typeof el === \'object\' && (t = el.nodeType) && (t == 1 || t == 9)\n  }\n\n  function uniq(ar) {\n    var a = [], i, j\n    label:\n    for (i = 0; i < ar.length; i++) {\n      for (j = 0; j < a.length; j++) {\n        if (a[j] == ar[i]) {\n          continue label\n        }\n      }\n      a[a.length] = ar[i]\n    }\n    return a\n  }\n\n\n  /**\n   * @param {string|Array.<Element>|Element|Node} selector\n   * @param {string|Array.<Element>|Element|Node=} opt_root\n   * @return {Array.<Element>}\n   */\n  function qwery(selector, opt_root) {\n    var m, root = (typeof opt_root == \'string\') ? qwery(opt_root)[0] : (opt_root || doc)\n    root = isFinite(root.length) && root[0] && !root.nodeName ? root[0] : root\n    if (!root || !selector) {\n      return []\n    }\n    if (doc.getElementsByClassName && selector == \'string\' && (m = selector.match(classOnly))) {\n      return toArray((root).getElementsByClassName(m[1]))\n    }\n    // using duck typing for \'a\' window or \'a\' document (not \'the\' window || document)\n    if (selector && (selector.document || (selector.nodeType && selector.nodeType == 9))) {\n      return !opt_root ? [selector] : []\n    }\n    if (isNode(selector)) {\n      return !opt_root || (isAncestor(selector, root)) ? [selector] : []\n    }\n    return toArray((root).querySelectorAll(selector))\n  }\n\n\n  qwery.uniq = uniq\n\n  return qwery\n}, this);\n//# sourceURL=/components/qwery/mobile/qwery-mobile.js");

eval("(function (name, context, definition) {\n  if (typeof module != \'undefined\' && module.exports) module.exports = definition()\n  else if (typeof define == \'function\' && define.amd) define(\'bonzo\',definition)\n  else context[name] = definition()\n})(\'bonzo\', this, function() {\n  var win = window\n    , doc = win.document\n    , html = doc.documentElement\n    , parentNode = \'parentNode\'\n    , specialAttributes = /^(checked|value|selected|disabled)$/i\n      // tags that we have trouble inserting *into*\n    , specialTags = /^(select|fieldset|table|tbody|tfoot|td|tr|colgroup)$/i\n    , simpleScriptTagRe = /\\s*<script +src=[\'\"]([^\'\"]+)[\'\"]>/\n    , table = [\'<table>\', \'</table>\', 1]\n    , td = [\'<table><tbody><tr>\', \'</tr></tbody></table>\', 3]\n    , option = [\'<select>\', \'</select>\', 1]\n    , noscope = [\'_\', \'\', 0, 1]\n    , tagMap = { // tags that we have trouble *inserting*\n          thead: table, tbody: table, tfoot: table, colgroup: table, caption: table\n        , tr: [\'<table><tbody>\', \'</tbody></table>\', 2]\n        , th: td , td: td\n        , col: [\'<table><colgroup>\', \'</colgroup></table>\', 2]\n        , fieldset: [\'<form>\', \'</form>\', 1]\n        , legend: [\'<form><fieldset>\', \'</fieldset></form>\', 2]\n        , option: option, optgroup: option\n        , script: noscope, style: noscope, link: noscope, param: noscope, base: noscope\n      }\n    , stateAttributes = /^(checked|selected|disabled)$/\n    , ie = /msie/i.test(navigator.userAgent)\n    , hasClass, addClass, removeClass\n    , uidMap = {}\n    , uuids = 0\n    , digit = /^-?[\\d\\.]+$/\n    , dattr = /^data-(.+)$/\n    , px = \'px\'\n    , setAttribute = \'setAttribute\'\n    , getAttribute = \'getAttribute\'\n    , byTag = \'getElementsByTagName\'\n    , features = function() {\n        var e = doc.createElement(\'p\')\n        e.innerHTML = \'<a href=\"#x\">x</a><table style=\"float:left;\"></table>\'\n        return {\n          hrefExtended: e[byTag](\'a\')[0][getAttribute](\'href\') != \'#x\' // IE < 8\n        , autoTbody: e[byTag](\'tbody\').length !== 0 // IE < 8\n        , computedStyle: doc.defaultView && doc.defaultView.getComputedStyle\n        , cssFloat: e[byTag](\'table\')[0].style.styleFloat ? \'styleFloat\' : \'cssFloat\'\n        , transform: function () {\n            var props = [\'transform\', \'webkitTransform\', \'MozTransform\', \'OTransform\', \'msTransform\'], i\n            for (i = 0; i < props.length; i++) {\n              if (props[i] in e.style) return props[i]\n            }\n          }()\n        , classList: \'classList\' in e\n        , opasity: function () {\n            return typeof doc.createElement(\'a\').style.opacity !== \'undefined\'\n          }()\n        }\n      }()\n    , trimReplace = /(^\\s*|\\s*$)/g\n    , whitespaceRegex = /\\s+/\n    , toString = String.prototype.toString\n    , unitless = { lineHeight: 1, zoom: 1, zIndex: 1, opacity: 1, boxFlex: 1, WebkitBoxFlex: 1, MozBoxFlex: 1 }\n    , query = doc.querySelectorAll && function (selector) { return doc.querySelectorAll(selector) }\n    , trim = String.prototype.trim ?\n        function (s) {\n          return s.trim()\n        } :\n        function (s) {\n          return s.replace(trimReplace, \'\')\n        }\n\n    , getStyle = features.computedStyle\n        ? function (el, property) {\n            var value = null\n              , computed = doc.defaultView.getComputedStyle(el, \'\')\n            computed && (value = computed[property])\n            return el.style[property] || value\n          }\n        : !(ie && html.currentStyle)\n          ? function (el, property) {\n              return el.style[property]\n            }\n          :\n          /**\n           * @param {Element} el\n           * @param {string} property\n           * @return {string|number}\n           */\n          function (el, property) {\n            var val, value\n            if (property == \'opacity\' && !features.opasity) {\n              val = 100\n              try {\n                val = el[\'filters\'][\'DXImageTransform.Microsoft.Alpha\'].opacity\n              } catch (e1) {\n                try {\n                  val = el[\'filters\'](\'alpha\').opacity\n                } catch (e2) {}\n              }\n              return val / 100\n            }\n            value = el.currentStyle ? el.currentStyle[property] : null\n            return el.style[property] || value\n          }\n\n  function isNode(node) {\n    return node && node.nodeName && (node.nodeType == 1 || node.nodeType == 11)\n  }\n\n\n  function normalize(node, host, clone) {\n    var i, l, ret\n    if (typeof node == \'string\') return bonzo.create(node)\n    if (isNode(node)) node = [ node ]\n    if (clone) {\n      ret = [] // don\'t change original array\n      for (i = 0, l = node.length; i < l; i++) ret[i] = cloneNode(host, node[i])\n      return ret\n    }\n    return node\n  }\n\n  /**\n   * @param {string} c a class name to test\n   * @return {boolean}\n   */\n  function classReg(c) {\n    return new RegExp(\'(^|\\\\s+)\' + c + \'(\\\\s+|$)\')\n  }\n\n\n  /**\n   * @param {Bonzo|Array} ar\n   * @param {function(Object, number, (Bonzo|Array))} fn\n   * @param {Object=} opt_scope\n   * @param {boolean=} opt_rev\n   * @return {Bonzo|Array}\n   */\n  function each(ar, fn, opt_scope, opt_rev) {\n    var ind, i = 0, l = ar.length\n    for (; i < l; i++) {\n      ind = opt_rev ? ar.length - i - 1 : i\n      fn.call(opt_scope || ar[ind], ar[ind], ind, ar)\n    }\n    return ar\n  }\n\n\n  /**\n   * @param {Bonzo|Array} ar\n   * @param {function(Object, number, (Bonzo|Array))} fn\n   * @param {Object=} opt_scope\n   * @return {Bonzo|Array}\n   */\n  function deepEach(ar, fn, opt_scope) {\n    for (var i = 0, l = ar.length; i < l; i++) {\n      if (isNode(ar[i])) {\n        deepEach(ar[i].childNodes, fn, opt_scope)\n        fn.call(opt_scope || ar[i], ar[i], i, ar)\n      }\n    }\n    return ar\n  }\n\n\n  /**\n   * @param {string} s\n   * @return {string}\n   */\n  function camelize(s) {\n    return s.replace(/-(.)/g, function (m, m1) {\n      return m1.toUpperCase()\n    })\n  }\n\n\n  /**\n   * @param {string} s\n   * @return {string}\n   */\n  function decamelize(s) {\n    return s ? s.replace(/([a-z])([A-Z])/g, \'$1-$2\').toLowerCase() : s\n  }\n\n\n  /**\n   * @param {Element} el\n   * @return {*}\n   */\n  function data(el) {\n    el[getAttribute](\'data-node-uid\') || el[setAttribute](\'data-node-uid\', ++uuids)\n    var uid = el[getAttribute](\'data-node-uid\')\n    return uidMap[uid] || (uidMap[uid] = {})\n  }\n\n\n  /**\n   * removes the data associated with an element\n   * @param {Element} el\n   */\n  function clearData(el) {\n    var uid = el[getAttribute](\'data-node-uid\')\n    if (uid) delete uidMap[uid]\n  }\n\n\n  function dataValue(d) {\n    var f\n    try {\n      return (d === null || d === undefined) ? undefined :\n        d === \'true\' ? true :\n          d === \'false\' ? false :\n            d === \'null\' ? null :\n              (f = parseFloat(d)) == d ? f : d;\n    } catch(e) {}\n    return undefined\n  }\n\n\n  /**\n   * @param {Bonzo|Array} ar\n   * @param {function(Object, number, (Bonzo|Array))} fn\n   * @param {Object=} opt_scope\n   * @return {boolean} whether `some`thing was found\n   */\n  function some(ar, fn, opt_scope) {\n    for (var i = 0, j = ar.length; i < j; ++i) if (fn.call(opt_scope || null, ar[i], i, ar)) return true\n    return false\n  }\n\n\n  /**\n   * this could be a giant enum of CSS properties\n   * but in favor of file size sans-closure deadcode optimizations\n   * we\'re just asking for any ol string\n   * then it gets transformed into the appropriate style property for JS access\n   * @param {string} p\n   * @return {string}\n   */\n  function styleProperty(p) {\n      (p == \'transform\' && (p = features.transform)) ||\n        (/^transform-?[Oo]rigin$/.test(p) && (p = features.transform + \'Origin\')) ||\n        (p == \'float\' && (p = features.cssFloat))\n      return p ? camelize(p) : null\n  }\n\n  // this insert method is intense\n  function insert(target, host, fn, rev) {\n    var i = 0, self = host || this, r = []\n      // target nodes could be a css selector if it\'s a string and a selector engine is present\n      // otherwise, just use target\n      , nodes = query && typeof target == \'string\' && target.charAt(0) != \'<\' ? query(target) : target\n    // normalize each node in case it\'s still a string and we need to create nodes on the fly\n    each(normalize(nodes), function (t, j) {\n      each(self, function (el) {\n        fn(t, r[i++] = j > 0 ? cloneNode(self, el) : el)\n      }, null, rev)\n    }, this, rev)\n    self.length = i\n    each(r, function (e) {\n      self[--i] = e\n    }, null, !rev)\n    return self\n  }\n\n\n  /**\n   * sets an element to an explicit x/y position on the page\n   * @param {Element} el\n   * @param {?number} x\n   * @param {?number} y\n   */\n  function xy(el, x, y) {\n    var $el = bonzo(el)\n      , style = $el.css(\'position\')\n      , offset = $el.offset()\n      , rel = \'relative\'\n      , isRel = style == rel\n      , delta = [parseInt($el.css(\'left\'), 10), parseInt($el.css(\'top\'), 10)]\n\n    if (style == \'static\') {\n      $el.css(\'position\', rel)\n      style = rel\n    }\n\n    isNaN(delta[0]) && (delta[0] = isRel ? 0 : el.offsetLeft)\n    isNaN(delta[1]) && (delta[1] = isRel ? 0 : el.offsetTop)\n\n    x != null && (el.style.left = x - offset.left + delta[0] + px)\n    y != null && (el.style.top = y - offset.top + delta[1] + px)\n\n  }\n\n  // classList support for class management\n  // altho to be fair, the api sucks because it won\'t accept multiple classes at once\n  if (features.classList) {\n    hasClass = function (el, c) {\n      return el.classList.contains(c)\n    }\n    addClass = function (el, c) {\n      el.classList.add(c)\n    }\n    removeClass = function (el, c) {\n      el.classList.remove(c)\n    }\n  }\n  else {\n    hasClass = function (el, c) {\n      return classReg(c).test(el.className)\n    }\n    addClass = function (el, c) {\n      el.className = trim(el.className + \' \' + c)\n    }\n    removeClass = function (el, c) {\n      el.className = trim(el.className.replace(classReg(c), \' \'))\n    }\n  }\n\n\n  /**\n   * this allows method calling for setting values\n   *\n   * @example\n   * bonzo(elements).css(\'color\', function (el) {\n   *   return el.getAttribute(\'data-original-color\')\n   * })\n   *\n   * @param {Element} el\n   * @param {function (Element)|string}\n   * @return {string}\n   */\n  function setter(el, v) {\n    return typeof v == \'function\' ? v(el) : v\n  }\n\n  function scroll(x, y, type) {\n    var el = this[0]\n    if (!el) return this\n    if (x == null && y == null) {\n      return (isBody(el) ? getWindowScroll() : { x: el.scrollLeft, y: el.scrollTop })[type]\n    }\n    if (isBody(el)) {\n      win.scrollTo(x, y)\n    } else {\n      x != null && (el.scrollLeft = x)\n      y != null && (el.scrollTop = y)\n    }\n    return this\n  }\n\n  /**\n   * @constructor\n   * @param {Array.<Element>|Element|Node|string} elements\n   */\n  function Bonzo(elements) {\n    this.length = 0\n    if (elements) {\n      elements = typeof elements !== \'string\' &&\n        !elements.nodeType &&\n        typeof elements.length !== \'undefined\' ?\n          elements :\n          [elements]\n      this.length = elements.length\n      for (var i = 0; i < elements.length; i++) this[i] = elements[i]\n    }\n  }\n\n  Bonzo.prototype = {\n\n      /**\n       * @param {number} index\n       * @return {Element|Node}\n       */\n      get: function (index) {\n        return this[index] || null\n      }\n\n      // itetators\n      /**\n       * @param {function(Element|Node)} fn\n       * @param {Object=} opt_scope\n       * @return {Bonzo}\n       */\n    , each: function (fn, opt_scope) {\n        return each(this, fn, opt_scope)\n      }\n\n      /**\n       * @param {Function} fn\n       * @param {Object=} opt_scope\n       * @return {Bonzo}\n       */\n    , deepEach: function (fn, opt_scope) {\n        return deepEach(this, fn, opt_scope)\n      }\n\n\n      /**\n       * @param {Function} fn\n       * @param {Function=} opt_reject\n       * @return {Array}\n       */\n    , map: function (fn, opt_reject) {\n        var m = [], n, i\n        for (i = 0; i < this.length; i++) {\n          n = fn.call(this, this[i], i)\n          opt_reject ? (opt_reject(n) && m.push(n)) : m.push(n)\n        }\n        return m\n      }\n\n    // text and html inserters!\n\n    /**\n     * @param {string} h the HTML to insert\n     * @param {boolean=} opt_text whether to set or get text content\n     * @return {Bonzo|string}\n     */\n    , html: function (h, opt_text) {\n        var method = opt_text\n              ? html.textContent === undefined ? \'innerText\' : \'textContent\'\n              : \'innerHTML\'\n          , that = this\n          , append = function (el, i) {\n              each(normalize(h, that, i), function (node) {\n                el.appendChild(node)\n              })\n            }\n          , updateElement = function (el, i) {\n              try {\n                if (opt_text || (typeof h == \'string\' && !specialTags.test(el.tagName))) {\n                  return el[method] = h\n                }\n              } catch (e) {}\n              append(el, i)\n            }\n        return typeof h != \'undefined\'\n          ? this.empty().each(updateElement)\n          : this[0] ? this[0][method] : \'\'\n      }\n\n      /**\n       * @param {string=} opt_text the text to set, otherwise this is a getter\n       * @return {Bonzo|string}\n       */\n    , text: function (opt_text) {\n        return this.html(opt_text, true)\n      }\n\n      // more related insertion methods\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , append: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el.appendChild(i)\n          })\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , prepend: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          var first = el.firstChild\n          each(normalize(node, that, i), function (i) {\n            el.insertBefore(i, first)\n          })\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you\'ll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , appendTo: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          t.appendChild(el)\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you\'ll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , prependTo: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          t.insertBefore(el, t.firstChild)\n        }, 1)\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , before: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el[parentNode].insertBefore(i, el)\n          })\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , after: function (node) {\n        var that = this\n        return this.each(function (el, i) {\n          each(normalize(node, that, i), function (i) {\n            el[parentNode].insertBefore(i, el.nextSibling)\n          }, null, 1)\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you\'ll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , insertBefore: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          t[parentNode].insertBefore(el, t)\n        })\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} target the location for which you\'ll insert your new content\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , insertAfter: function (target, opt_host) {\n        return insert.call(this, target, opt_host, function (t, el) {\n          var sibling = t.nextSibling\n          sibling ?\n            t[parentNode].insertBefore(el, sibling) :\n            t[parentNode].appendChild(el)\n        }, 1)\n      }\n\n\n      /**\n       * @param {Bonzo|string|Element|Array} node\n       * @return {Bonzo}\n       */\n    , replaceWith: function (node) {\n        bonzo(normalize(node)).insertAfter(this)\n        return this.remove()\n      }\n\n      /**\n       * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)\n       * @return {Bonzo}\n       */\n    , clone: function (opt_host) {\n        var ret = [] // don\'t change original array\n          , l, i\n        for (i = 0, l = this.length; i < l; i++) ret[i] = cloneNode(opt_host || this, this[i])\n        return bonzo(ret)\n      }\n\n      // class management\n\n      /**\n       * @param {string} c\n       * @return {Bonzo}\n       */\n    , addClass: function (c) {\n        c = toString.call(c).split(whitespaceRegex)\n        return this.each(function (el) {\n          // we `each` here so you can do $el.addClass(\'foo bar\')\n          each(c, function (c) {\n            if (c && !hasClass(el, setter(el, c)))\n              addClass(el, setter(el, c))\n          })\n        })\n      }\n\n\n      /**\n       * @param {string} c\n       * @return {Bonzo}\n       */\n    , removeClass: function (c) {\n        c = toString.call(c).split(whitespaceRegex)\n        return this.each(function (el) {\n          each(c, function (c) {\n            if (c && hasClass(el, setter(el, c)))\n              removeClass(el, setter(el, c))\n          })\n        })\n      }\n\n\n      /**\n       * @param {string} c\n       * @return {boolean}\n       */\n    , hasClass: function (c) {\n        c = toString.call(c).split(whitespaceRegex)\n        return some(this, function (el) {\n          return some(c, function (c) {\n            return c && hasClass(el, c)\n          })\n        })\n      }\n\n\n      /**\n       * @param {string} c classname to toggle\n       * @param {boolean=} opt_condition whether to add or remove the class straight away\n       * @return {Bonzo}\n       */\n    , toggleClass: function (c, opt_condition) {\n        c = toString.call(c).split(whitespaceRegex)\n        return this.each(function (el) {\n          each(c, function (c) {\n            if (c) {\n              typeof opt_condition !== \'undefined\' ?\n                opt_condition ? !hasClass(el, c) && addClass(el, c) : removeClass(el, c) :\n                hasClass(el, c) ? removeClass(el, c) : addClass(el, c)\n            }\n          })\n        })\n      }\n\n      // display togglers\n\n      /**\n       * @param {string=} opt_type useful to set back to anything other than an empty string\n       * @return {Bonzo}\n       */\n    , show: function (opt_type) {\n        opt_type = typeof opt_type == \'string\' ? opt_type : \'\'\n        return this.each(function (el) {\n          el.style.display = opt_type\n        })\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , hide: function () {\n        return this.each(function (el) {\n          el.style.display = \'none\'\n        })\n      }\n\n\n      /**\n       * @param {Function=} opt_callback\n       * @param {string=} opt_type\n       * @return {Bonzo}\n       */\n    , toggle: function (opt_callback, opt_type) {\n        opt_type = typeof opt_type == \'string\' ? opt_type : \'\';\n        typeof opt_callback != \'function\' && (opt_callback = null)\n        return this.each(function (el) {\n          el.style.display = (el.offsetWidth || el.offsetHeight) ? \'none\' : opt_type;\n          opt_callback && opt_callback.call(el)\n        })\n      }\n\n\n      // DOM Walkers & getters\n\n      /**\n       * @return {Element|Node}\n       */\n    , first: function () {\n        return bonzo(this.length ? this[0] : [])\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , last: function () {\n        return bonzo(this.length ? this[this.length - 1] : [])\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , next: function () {\n        return this.related(\'nextSibling\')\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , previous: function () {\n        return this.related(\'previousSibling\')\n      }\n\n\n      /**\n       * @return {Element|Node}\n       */\n    , parent: function() {\n        return this.related(parentNode)\n      }\n\n\n      /**\n       * @private\n       * @param {string} method the directional DOM method\n       * @return {Element|Node}\n       */\n    , related: function (method) {\n        return bonzo(this.map(\n          function (el) {\n            el = el[method]\n            while (el && el.nodeType !== 1) {\n              el = el[method]\n            }\n            return el || 0\n          },\n          function (el) {\n            return el\n          }\n        ))\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , focus: function () {\n        this.length && this[0].focus()\n        return this\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , blur: function () {\n        this.length && this[0].blur()\n        return this\n      }\n\n      // style getter setter & related methods\n\n      /**\n       * @param {Object|string} o\n       * @param {string=} opt_v\n       * @return {Bonzo|string}\n       */\n    , css: function (o, opt_v) {\n        var p, iter = o\n        // is this a request for just getting a style?\n        if (opt_v === undefined && typeof o == \'string\') {\n          // repurpose \'v\'\n          opt_v = this[0]\n          if (!opt_v) return null\n          if (opt_v === doc || opt_v === win) {\n            p = (opt_v === doc) ? bonzo.doc() : bonzo.viewport()\n            return o == \'width\' ? p.width : o == \'height\' ? p.height : \'\'\n          }\n          return (o = styleProperty(o)) ? getStyle(opt_v, o) : null\n        }\n\n        if (typeof o == \'string\') {\n          iter = {}\n          iter[o] = opt_v\n        }\n\n        if (!features.opasity && \'opacity\' in iter) {\n          // oh this \'ol gamut\n          iter.filter = iter.opacity != null && iter.opacity !== \'\'\n            ? \'alpha(opacity=\' + (iter.opacity * 100) + \')\'\n            : \'\'\n          // give it layout\n          iter.zoom = o.zoom || 1\n          ;delete iter.opacity\n        }\n\n        function fn(el, p, v) {\n          for (var k in iter) {\n            if (iter.hasOwnProperty(k)) {\n              v = iter[k];\n              // change \"5\" to \"5px\" - unless you\'re line-height, which is allowed\n              (p = styleProperty(k)) && digit.test(v) && !(p in unitless) && (v += px)\n              try { el.style[p] = setter(el, v) } catch(e) {}\n            }\n          }\n        }\n        return this.each(fn)\n      }\n\n\n      /**\n       * @param {number=} opt_x\n       * @param {number=} opt_y\n       * @return {Bonzo|number}\n       */\n    , offset: function (opt_x, opt_y) {\n        if (opt_x && typeof opt_x == \'object\' && (typeof opt_x.top == \'number\' || typeof opt_x.left == \'number\')) {\n          return this.each(function (el) {\n            xy(el, opt_x.left, opt_x.top)\n          })\n        } else if (typeof opt_x == \'number\' || typeof opt_y == \'number\') {\n          return this.each(function (el) {\n            xy(el, opt_x, opt_y)\n          })\n        }\n        if (!this[0]) return {\n            top: 0\n          , left: 0\n          , height: 0\n          , width: 0\n        }\n        var el = this[0]\n          , de = el.ownerDocument.documentElement\n          , bcr = el.getBoundingClientRect()\n          , scroll = getWindowScroll()\n          , width = el.offsetWidth\n          , height = el.offsetHeight\n          , top = bcr.top + scroll.y - Math.max(0, de && de.clientTop, doc.body.clientTop)\n          , left = bcr.left + scroll.x - Math.max(0, de && de.clientLeft, doc.body.clientLeft)\n\n        return {\n            top: top\n          , left: left\n          , height: height\n          , width: width\n        }\n      }\n\n\n      /**\n       * @return {number}\n       */\n    , dim: function () {\n        if (!this.length) return { height: 0, width: 0 }\n        var el = this[0]\n          , de = el.nodeType == 9 && el.documentElement // document\n          , orig = !de && !!el.style && !el.offsetWidth && !el.offsetHeight ?\n             // el isn\'t visible, can\'t be measured properly, so fix that\n             function (t) {\n               var s = {\n                   position: el.style.position || \'\'\n                 , visibility: el.style.visibility || \'\'\n                 , display: el.style.display || \'\'\n               }\n               t.first().css({\n                   position: \'absolute\'\n                 , visibility: \'hidden\'\n                 , display: \'block\'\n               })\n               return s\n            }(this) : null\n          , width = de\n              ? Math.max(el.body.scrollWidth, el.body.offsetWidth, de.scrollWidth, de.offsetWidth, de.clientWidth)\n              : el.offsetWidth\n          , height = de\n              ? Math.max(el.body.scrollHeight, el.body.offsetHeight, de.scrollHeight, de.offsetHeight, de.clientHeight)\n              : el.offsetHeight\n\n        orig && this.first().css(orig)\n        return {\n            height: height\n          , width: width\n        }\n      }\n\n      // attributes are hard. go shopping\n\n      /**\n       * @param {string} k an attribute to get or set\n       * @param {string=} opt_v the value to set\n       * @return {Bonzo|string}\n       */\n    , attr: function (k, opt_v) {\n        var el = this[0]\n          , n\n\n        if (typeof k != \'string\' && !(k instanceof String)) {\n          for (n in k) {\n            k.hasOwnProperty(n) && this.attr(n, k[n])\n          }\n          return this\n        }\n\n        return typeof opt_v == \'undefined\' ?\n          !el ? null : specialAttributes.test(k) ?\n            stateAttributes.test(k) && typeof el[k] == \'string\' ?\n              true : el[k] : (k == \'href\' || k ==\'src\') && features.hrefExtended ?\n                el[getAttribute](k, 2) : el[getAttribute](k) :\n          this.each(function (el) {\n            specialAttributes.test(k) ? (el[k] = setter(el, opt_v)) : el[setAttribute](k, setter(el, opt_v))\n          })\n      }\n\n\n      /**\n       * @param {string} k\n       * @return {Bonzo}\n       */\n    , removeAttr: function (k) {\n        return this.each(function (el) {\n          stateAttributes.test(k) ? (el[k] = false) : el.removeAttribute(k)\n        })\n      }\n\n\n      /**\n       * @param {string=} opt_s\n       * @return {Bonzo|string}\n       */\n    , val: function (s) {\n        return (typeof s == \'string\' || typeof s == \'number\') ?\n          this.attr(\'value\', s) :\n          this.length ? this[0].value : null\n      }\n\n      // use with care and knowledge. this data() method uses data attributes on the DOM nodes\n      // to do this differently costs a lot more code. c\'est la vie\n      /**\n       * @param {string|Object=} opt_k the key for which to get or set data\n       * @param {Object=} opt_v\n       * @return {Bonzo|Object}\n       */\n    , data: function (opt_k, opt_v) {\n        var el = this[0], o, m\n        if (typeof opt_v === \'undefined\') {\n          if (!el) return null\n          o = data(el)\n          if (typeof opt_k === \'undefined\') {\n            each(el.attributes, function (a) {\n              (m = (\'\' + a.name).match(dattr)) && (o[camelize(m[1])] = dataValue(a.value))\n            })\n            return o\n          } else {\n            if (typeof o[opt_k] === \'undefined\')\n              o[opt_k] = dataValue(this.attr(\'data-\' + decamelize(opt_k)))\n            return o[opt_k]\n          }\n        } else {\n          return this.each(function (el) { data(el)[opt_k] = opt_v })\n        }\n      }\n\n      // DOM detachment & related\n\n      /**\n       * @return {Bonzo}\n       */\n    , remove: function () {\n        this.deepEach(clearData)\n        return this.detach()\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , empty: function () {\n        return this.each(function (el) {\n          deepEach(el.childNodes, clearData)\n\n          while (el.firstChild) {\n            el.removeChild(el.firstChild)\n          }\n        })\n      }\n\n\n      /**\n       * @return {Bonzo}\n       */\n    , detach: function () {\n        return this.each(function (el) {\n          el[parentNode] && el[parentNode].removeChild(el)\n        })\n      }\n\n      // who uses a mouse anyway? oh right.\n\n      /**\n       * @param {number} y\n       */\n    , scrollTop: function (y) {\n        return scroll.call(this, null, y, \'y\')\n      }\n\n\n      /**\n       * @param {number} x\n       */\n    , scrollLeft: function (x) {\n        return scroll.call(this, x, null, \'x\')\n      }\n\n  }\n\n\n  function cloneNode(host, el) {\n    var c = el.cloneNode(true)\n      , cloneElems\n      , elElems\n      , i\n\n    // check for existence of an event cloner\n    // preferably https://github.com/fat/bean\n    // otherwise Bonzo won\'t do this for you\n    if (host.$ && typeof host.cloneEvents == \'function\') {\n      host.$(c).cloneEvents(el)\n\n      // clone events from every child node\n      cloneElems = host.$(c).find(\'*\')\n      elElems = host.$(el).find(\'*\')\n\n      for (i = 0; i < elElems.length; i++)\n        host.$(cloneElems[i]).cloneEvents(elElems[i])\n    }\n    return c\n  }\n\n  function isBody(element) {\n    return element === win || (/^(?:body|html)$/i).test(element.tagName)\n  }\n\n  function getWindowScroll() {\n    return { x: win.pageXOffset || html.scrollLeft, y: win.pageYOffset || html.scrollTop }\n  }\n\n  function createScriptFromHtml(html) {\n    var scriptEl = document.createElement(\'script\')\n      , matches = html.match(simpleScriptTagRe)\n    scriptEl.src = matches[1]\n    return scriptEl\n  }\n\n  /**\n   * @param {Array.<Element>|Element|Node|string} els\n   * @return {Bonzo}\n   */\n  function bonzo(els) {\n    return new Bonzo(els)\n  }\n\n  bonzo.setQueryEngine = function (q) {\n    query = q;\n    delete bonzo.setQueryEngine\n  }\n\n  bonzo.aug = function (o, target) {\n    // for those standalone bonzo users. this love is for you.\n    for (var k in o) {\n      o.hasOwnProperty(k) && ((target || Bonzo.prototype)[k] = o[k])\n    }\n  }\n\n  bonzo.create = function (node) {\n    // hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n    return typeof node == \'string\' && node !== \'\' ?\n      function () {\n        if (simpleScriptTagRe.test(node)) return [createScriptFromHtml(node)]\n        var tag = node.match(/^\\s*<([^\\s>]+)/)\n          , el = doc.createElement(\'div\')\n          , els = []\n          , p = tag ? tagMap[tag[1].toLowerCase()] : null\n          , dep = p ? p[2] + 1 : 1\n          , ns = p && p[3]\n          , pn = parentNode\n          , tb = features.autoTbody && p && p[0] == \'<table>\' && !(/<tbody/i).test(node)\n\n        el.innerHTML = p ? (p[0] + node + p[1]) : node\n        while (dep--) el = el.firstChild\n        // for IE NoScope, we may insert cruft at the begining just to get it to work\n        if (ns && el && el.nodeType !== 1) el = el.nextSibling\n        do {\n          // tbody special case for IE<8, creates tbody on any empty table\n          // we don\'t want it if we\'re just after a <thead>, <caption>, etc.\n          if ((!tag || el.nodeType == 1) && (!tb || (el.tagName && el.tagName != \'TBODY\'))) {\n            els.push(el)\n          }\n        } while (el = el.nextSibling)\n        // IE < 9 gives us a parentNode which messes up insert() check for cloning\n        // `dep` > 1 can also cause problems with the insert() check (must do this last)\n        each(els, function(el) { el[pn] && el[pn].removeChild(el) })\n        return els\n      }() : isNode(node) ? [node.cloneNode(true)] : []\n  }\n\n  bonzo.doc = function () {\n    var vp = bonzo.viewport()\n    return {\n        width: Math.max(doc.body.scrollWidth, html.scrollWidth, vp.width)\n      , height: Math.max(doc.body.scrollHeight, html.scrollHeight, vp.height)\n    }\n  }\n\n  bonzo.firstChild = function (el) {\n    for (var c = el.childNodes, i = 0, j = (c && c.length) || 0, e; i < j; i++) {\n      if (c[i].nodeType === 1) e = c[j = i]\n    }\n    return e\n  }\n\n  bonzo.viewport = function () {\n    return {\n        width: ie ? html.clientWidth : self.innerWidth\n      , height: ie ? html.clientHeight : self.innerHeight\n    }\n  }\n\n  bonzo.isAncestor = \'compareDocumentPosition\' in html ?\n    function (container, element) {\n      return (container.compareDocumentPosition(element) & 16) == 16\n    } : \'contains\' in html ?\n    function (container, element) {\n      return container !== element && container.contains(element);\n    } :\n    function (container, element) {\n      while (element = element[parentNode]) {\n        if (element === container) {\n          return true\n        }\n      }\n      return false\n    }\n\n  return bonzo\n}); // the only line we care about using a semi-colon. placed here for concatenation tools\n\n//# sourceURL=/components/bonzo/src/bonzo.js");

require([
    'qwery',
    'bonzo'
], function (qwery, bonzo) {

    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function addLine(event) {
        var $pushedContent = bonzo.create('<span>' + event.data + '</span><br>');
        bonzo($pushedContent).addClass('pushed-content lazyloaded');
        bonzo(qwery(".cursor")).before($pushedContent);
    }

    function connect(config) {

        var chatSocket = new window.WebSocket("ws://localhost:9000/eventStream");

        var receiveEvent = function(message) {

            console.log(message)

            if (message && 'data' in message) {
                var events = (JSON.parse(message.data)).events;

                events.forEach(function (event, index) {
                    var startTime = (index * 4000) + 2000;
                    var endTime = (index * 4000) + 5000;
                    window.setTimeout( function(){addLine(event)},getRandomInt( startTime, endTime ))
                    
                });

                // For now, just finish.
                chatSocket.close();

            } else {
                console.log('Invalid data returned from socket');
            }
        };

        var disconnectEvent = function(event) {
            chatSocket.close();
            //connect(config);
        };

        chatSocket.onmessage = receiveEvent;
        chatSocket.onerror = disconnectEvent;
        chatSocket.onclose = disconnectEvent;
    }

    connect();
});

define("app", function(){});
